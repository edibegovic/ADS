\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[danish]{babel}
\usepackage{utopia}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{cmap}

\title{Catenable Queues - ADS}
\author{Edi Begovic | Høgni Jacobsen | Gergö Koncz}
\date{\today}

\def\arraystretch{1.5}
\def\headline#1{\hbox to \hsize{\hrulefill\quad\lower.3em\hbox{#1}\quad\hrulefill}}

\begin{document} 
\maketitle

\ \\
\noindent
The pseudo-code will reference the queue on which the function is called as \textit{q}.
\ \\
\section*{Question 1}
\headline{-} \ \\

\noindent
The following implementation removes all occurances of a given item from the queue by defining a temporary queue
object to which we enqueue every item from the original queue which does not match the item for removal. 
Lastly, we replace the reference to q with the temporary queue.

\noindent
\begin{lstlisting}[escapeinside={{*}{*}}]

q.removeall(item):

    temporaryQueue = *\textbf{new}* queue

    *\textbf{While}* q.!isEmpty:

        Current = q.dequeue()
        
        *\textbf{if}* (current != item):
            temporaryQueue.enqueue(current)
    
    q = temporaryQueue

\end{lstlisting}

\newpage
\section*{Question 2}
\headline{-} \ \\
The following implementation 'concatenates' the queue \textit{p} onto the queue \textit{q} by
dequeueing every item of \textit{p} and enqueuing it on \textit{q}.
 \\

\noindent

\begin{lstlisting}[escapeinside={{*}{*}}]
    q.enqueueall(p):
        *\textbf{while}* !p.isEmpty():
            q.enqueue(p.dequeue)
\end{lstlisting}

\ \\
\section*{Question 3}
\headline{-} \ \\
This implementation of the FIFO queue is based on linked lists and thus we can simply set the 
'next'-pointer of the last node (of \textit{q}) to point to the first node of \textit{p}.
 \\

\noindent

\begin{lstlisting}[escapeinside={{*}{*}}]
    q.enqueueall(p):
        (q.last).ext = p.first
\end{lstlisting}
 
\ \\

\ \\
\section*{Question 4}
\headline{-} \ \\
A FIFO queue based on a resizing array would operate on the principle that an array is resized 
to double its size once full or half its size once capacity is at a quarter. The is achieved by keeping tracking of 
the number of items in the array, once the previously mentioned conditions are met then a new array 
of the appropriate size is created and enqueueall will be used to depopulate the old array and populate the new one.
\\



\end{document}