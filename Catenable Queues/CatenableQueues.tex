\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[danish]{babel}
\usepackage{utopia}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{cmap}

\title{Catenable Queues - ADS}
\author{Edi Begovic | Høgni Jacobsen | Gergö Koncz}
\date{\today}

\def\arraystretch{1.5}
\def\headline#1{\hbox to \hsize{\hrulefill\quad\lower.3em\hbox{#1}\quad\hrulefill}}

\begin{document} 
\maketitle

\ \\
\noindent
The pseudo-code will reference the queue on which the function is called as \textit{q}.
\ \\
\section*{Question 1}
\headline{-} \ \\

\noindent
The following implementation removes all occurances of the given item from the queue by defining a temporary queue
object to which we enqueue every item from the original queue that does not match the item for removal. 

Once the original queue is empty and we have the temporary q with all the elements in the proper order we considered two solutions. We could dequeue all the elements from the temporary queue and enqueue them all to the original one. However, since the temporary queue is the perfect queue that we need we change the reference of the original queue to the temporary one and trust the destiny of the original emptied queue to the garbage collector. 

\noindent
\begin{lstlisting}[escapeinside={{*}{*}}]

q.removeall(item):

    temporaryQueue = *\textbf{new}* queue

    *\textbf{While}* !q.isEmpty():

        Current = q.dequeue()
        
        *\textbf{if}* (current != item):
            temporaryQueue.enqueue(current)
    
    q = temporaryQueue

\end{lstlisting}

\newpage
\section*{Question 2}
\headline{-} \ \\
The following implementation 'concatenates' the queue \textit{p} onto the queue \textit{q} by
dequeueing every item of \textit{p} and enqueuing it on \textit{q}. The speed of this method depends on the size of the second queue, since all of the elements of that one are 'touched' in this method.

At the end it makes sense to change the reference of p to null since while it references the empty queue it can't be collected by the garbage collector. 

By later questions we will see that if we can use the underlying benefits of the linked list implementation the method is much quicker.
 \\

\noindent

\begin{lstlisting}[escapeinside={{*}{*}}]
    q.enqueueall(p):
        *\textbf{while}* !p.isEmpty():
            q.enqueue(p.dequeue)
    p = null
\end{lstlisting}

\ \\
\section*{Question 3}
\headline{-} \ \\
This implementation of the FIFO queue is based on linked lists thus we can simply set the 
'next'-pointer of the last node (of \textit{q}) to point to the first node of \textit{p}.

We are lucky enough that the implementation of the FIFO queue based on linked lists keeps a reference to both the first and the last elements of the queues, therefor no additional tracking of nodes is needed to realize this assignment.
 \\

\noindent

\begin{lstlisting}[escapeinside={{*}{*}}]
    q.enqueueall(p):
        (q.last).next = p.first
\end{lstlisting}
 
\ \\

\ \\
\section*{Question 4}
\headline{-} \ \\

As a starting point for our implementation of the  of the FIFO queue (using resizing arrays) the LIFO stack implementation (Sedgewick p 141) was very useful.

The structures are similar in a sense that for the queue we would use the same resize() and isEmpty() function and we would keep track of the size of the array the same way.

The push function of the stack is similar to the enqueue in the queue. However, while the push puts the element at the end of the array, in enqueue we would always put the elements at the beginning. Effecting, that before assigning  the 0 indexed of the array we would use the reverseIterator of the implementation to iterate through the array and increasing the index of all the elements. The ReverseIterator starts at the end of the array therefor we ant lose elements.

Before all that is executed we would check the size of the array and increase it once needed.

\begin{lstlisting}[escapeinside={{*}{*}}]
    q.enqueue(item):
    	if(N == a.length):
    		resize(2 a.length)
    	for element in a:
    		
\end{lstlisting}

\end{document}