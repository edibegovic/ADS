\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[danish]{babel}
\usepackage{utopia}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{cmap}

\title{Heaps - ADS}
\author{Edi Begovic | Høgni Jacobsen | Gergö Koncz}
\date{\today}

\def\arraystretch{1.5}
\def\headline#1{\hbox to \hsize{\hrulefill\quad\lower.3em\hbox{#1}\quad\hrulefill}}

\begin{document} 
\maketitle

\ \\
\noindent
The pseudo-code will reference the queue on which the function is called as \textit{q}.
\ \\
\section*{Question 1}
Assuming we wish to draw the resulting binary tree of a max heap:
\ \\
\begin{center}
\includegraphics[scale=0.16]{figure1.png}
\end{center}

\noindent
This results in the following array representation: 
$[6, 4, 5, 1, 2, 3]$


\ \\
\section*{Question 2}
\headline{a} \ \\

\noindent
Assuming the 'first' implies the pointer to the first element in the list 
(\textit{that is}, that last added item (p. 148)), answer \textbf{a} is correct.
\ \\

\begin{center}
\includegraphics[scale=0.22]{figure2.png}
\end{center}

\headline{b} \ \\

\noindent
The representation of the elements to be unionised have to be the same after the union and since there are already two elements with the number two as their representation it is quicker to change the representation of four to two.\\
\begin{center}
\begin{tabular}{|l|l|l|l|l|}
\hline
\textbf{0} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4}\\ 
\hline
0 & 1 & 2 & 2 & 2\\
\hline
\end{tabular}
\end{center}
\ \\

\headline{c} \ \\

\noindent
\textbf{Correct answer:} \\
1. The union operation is asymptotically faster, \textit{as the union operation is now bound by the tree tree height rather than
$N$}.



\ \\

\section*{Question 3}

\noindent
To implement the $min()$ function we cannot just always return the element with 
the last index of the array, since we cannot be certain that the elements at the 
same level are sorted. Also, we cannot iterate through the last level of the tree 
because that would take more than constant time, could be really long by bigger arrays.  
The implementation of a $min()$ function in constant time and space can be 
achieved by keeping track of the minimum element through a variable. We declare it when 
the first element is created, and once a new item is inserted, the new item will be 
compared with the current minimum and replaced if it is lesser than it.


\section*{Question 4}

\noindent
Tesinger...

\end{document} 