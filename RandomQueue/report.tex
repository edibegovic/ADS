\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[danish]{babel}
\usepackage{utopia}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{cmap}
\setlength\parindent{0pt}

\title{RandomQueue - ADS}
\author{Edi Begovic | Høgni Jacobsen | Gergő Koncz}
\date{\today}

\def\arraystretch{1.5}
\def\headline#1{\hbox to \hsize{\hrulefill\quad\lower.3em\hbox{#1}\quad\hrulefill}}

\begin{document} 
\maketitle

\ \\
\noindent
The following implementation of the RandomQueue exercise builds on "pseudo-arrays" made 
with the standard Python list type.
\ \\
\section*{Implementation of Randomqueue}

\noindent
Our program \texttt{RandomQueue.py} implements the complete API.
The submission at time [18-02-2019 22:03] passed all tests on CodeJudge. \\

The items are stored in a array-like datastructure (based on the list type in Python) in 
their sequential order. Maintaining the size of this array is done by implementing functionality of
the dynamic array from the lecures in the \textit{enqueue} and \textit{dequeue} functions, and 
thus never allocating more memmory than $4$ times the number of items in the data structure. 
Although the resizing functionality taking linear time, it's amortized time (\textit{averege}, if you will)
is constant.\\

The \texttt{enqueue}  operation uses  a resizing list implementation. Values are sequentially 
assigning to the indexes of the list.
\texttt{enqueue} is achieved in constant time. \\

The \texttt{sample} operation uses a random integer to select a random index in the list. This is 
achieved in constant time. \\

The \texttt{dequeue} operation uses a resizing list implementation. The \texttt{dequeue} 
operation selects a random integer in the range of the list as the index of the element to 
return. After this, the last element of the list gets assigned to the index of the deleted 
element, keeping all the items in the first part of the array.  \\

In our implementation, the iterator creates an empty list of the same size as the amount of 
elements in the original list. The original list is then iterate over and the values in it 
is copied to the new list, our implementation does not copy empty values. For shuffling, the 
\textit{Knuth Shuffle} algorithm is used, which is "swaps" $~n$ random indexes in the list.
All three operations take linear time, while only allocating memmory for an $n$-sized array. \\

\end{document}